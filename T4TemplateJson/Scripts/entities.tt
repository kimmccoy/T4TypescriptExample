<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".ts" #>
<# /* Load the current project's DLL to make sure this can find things */ #>
<#@ assembly name="$(TargetPath)" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Web" #>
<#@ assembly name="System.Web.Extensions" #>
<#@ assembly name="System.ComponentModel.DataAnnotations" #>
<#@ assembly name="System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ assembly name="System.Xml.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.ComponentModel.DataAnnotations" #>

<#
	var allTypes = typeof(T4TemplateJson.ScriptDtoAttribute).Assembly.GetTypes()
		.Where(t => t.IsAbstract == false 
		&& t.IsEnum == false
		&& t.IsClass
		&& t.GetCustomAttributes(typeof(T4TemplateJson.ScriptDtoAttribute), true).Length > 0);

	var allEnums = typeof(T4TemplateJson.ScriptDtoAttribute).Assembly.GetTypes()
		.Where(t => t.IsEnum == true
		&& t.GetCustomAttributes(typeof(T4TemplateJson.ScriptDtoAttribute), true).Length > 0);
#>

/**
* Autogenerated file at <#= System.DateTime.Now.ToString() #>
*/
 
module models {

	export class ModelHelpers{

	    /** 
		 * Loads dates when they are supplied in old ASXM format of /Date(123456798)/
		 * Change if using normal json date formats.
		 */
		public static loadDate(value: any):Date{
			if(value == null || value == undefined){
				return null;
			}else if(value instanceof Date){
				return value;
			}else if(typeof value == 'string'){
				return new Date(value);
			}
		}
	}

<# foreach(var t in allTypes){ #>
	export class <#= t.Name #>{

<#
var loaderItems = new List<string>();
var saverItems = new List<string>();

foreach(var member in t.GetProperties())
{

	var propertyInfo = member;

	if(member.CustomAttributes.Any(x=>x.AttributeType == typeof(System.Web.Script.Serialization.ScriptIgnoreAttribute))){
		continue; //don't include
	}

    var description = "";

    var displayAttribute = propertyInfo.GetCustomAttributes(typeof(DisplayAttribute),true)
		.OfType<DisplayAttribute>()
        .FirstOrDefault<DisplayAttribute>();

    if(displayAttribute != null){
		if(displayAttribute.Description != null){
			description = displayAttribute.Description;
        }
    }

	var typeName = GetTypeContractName(propertyInfo.PropertyType);

	var isEnumerable = !propertyInfo.PropertyType.IsEnum 
						&& ((propertyInfo.PropertyType.IsGenericType && typeof(ICollection<>).IsAssignableFrom(propertyInfo.PropertyType.GetGenericTypeDefinition()))
						|| typeof(Array).IsAssignableFrom(propertyInfo.PropertyType));

	var isClass = isClassType(propertyInfo.PropertyType);
	var isDate = typeof(DateTime) == propertyInfo.PropertyType;
	 
	if(isEnumerable){
	
		Type elementType;
		if(propertyInfo.PropertyType.IsGenericType){
			elementType = propertyInfo.PropertyType.GenericTypeArguments[0];
        }else{
			elementType = propertyInfo.PropertyType.GetElementType();
		}

		typeName = GetTypeContractName(elementType);
		loaderItems.Add("this." + FirstCharLowered(member.Name) + ".removeAll();");
		loaderItems.Add("data." + member.Name + ".forEach((x)=>{ this." + FirstCharLowered(member.Name) + ".push(new " + typeName + "().load(x)); });");
		saverItems.Add(member.Name + " : this." + FirstCharLowered(member.Name) + "().map((x)=> {return x.save();})"); 
		#>
		 
	/**
	* <#=description #>
	*/
	public <#=FirstCharLowered(member.Name) #>: KnockoutObservableArray<<#= typeName #>> = ko.observableArray([]);
		<#


	}else{
		if(isClass){
			loaderItems.Add("this." + FirstCharLowered(member.Name) + "(new " + typeName + "().load(data." + member.Name + "))"); 
			saverItems.Add(member.Name + " : this." + FirstCharLowered(member.Name) + "().save()"); 
        }else if(isDate){
			loaderItems.Add("this." + FirstCharLowered(member.Name) + "(Models.ModelHelpers.loadDate(data." + member.Name + "))"); 
			saverItems.Add(member.Name + " : this." + FirstCharLowered(member.Name) + "()");        
		}else{
 			loaderItems.Add("this." + FirstCharLowered(member.Name) + "(data." + member.Name + ")"); 
			saverItems.Add(member.Name + " : this." + FirstCharLowered(member.Name) + "()");        
		}

		#>
	/**
	* <#=description #>
	*/
	public <#=FirstCharLowered(member.Name) #>: KnockoutObservable<<#= typeName #>> = ko.observable(null);

		<#
	}
} 
#>

	/**
	* Loads the object from a dto
	*/
	public load(data: any): <#= t.Name #>
	{
		if(data == null) return null;
	<# foreach(var line in loaderItems){ #>
	<#= line #>
	<#}#>
	return this;
	}

	/**
	* Save the object to a DTO
	*/
	public save(): any{
		return {
		<# foreach(var line in saverItems){ #>
		<#= line #>,
		<#}#>
		};
	}

	}//end class

<# } #>



<# foreach(var t in allEnums){ #>
	export enum <#= t.Name #>{
	 
<#

foreach(var value in Enum.GetValues(t)){
	var line = value.ToString() + " = " + (int)value + ","; #>
	<#= line #>
	<#
}#>
	}//end enum
<# } #>

}//end module

<#+

    private Stack<Type> viewTypes = new Stack<Type>();
    private HashSet<Type> doneTypes = new HashSet<Type>();

	private bool isClassType(Type type){
		var isIndexed = typeof(ICollection<>).IsAssignableFrom(type)
						|| typeof(Array).IsAssignableFrom(type);

		if(isIndexed){
			type = type.GetElementType();
		}
		return type != typeof(string) &&  type.IsClass;
    }

    private string GetTypeContractName(Type type)
    {
        if (type == typeof (Task))
        {
            return "void /*task*/";
        }

        if (type.IsArray)
        {
            return GetTypeContractName(type.GetElementType())+"[]";
        }

        if (type.IsGenericType && typeof(Task<>).IsAssignableFrom(type.GetGenericTypeDefinition()))
        {
            return GetTypeContractName(type.GetGenericArguments()[0]);
        }

        if (type.IsGenericType && typeof(Nullable<>).IsAssignableFrom(type.GetGenericTypeDefinition()))
        {
            return GetTypeContractName(type.GetGenericArguments()[0]);
        }

        if (type.IsGenericType && typeof(List<>).IsAssignableFrom(type.GetGenericTypeDefinition()))
        {
            return GetTypeContractName(type.GetGenericArguments()[0])+"[]";
        }

    

        switch (type.Name.ToLowerInvariant())
        {

            case "datetime":
				return "Date";
			case "guid":
                return "string";
            case "int16":
            case "int32":
            case "int64":
            case "single":
            case "double":
			case "decimal":
                return "number";
            case "boolean":
                return "boolean";
            case "void":
            case "string":
                return type.Name.ToLowerInvariant();
        }

        if (!doneTypes.Contains(type))
        {
            doneTypes.Add(type);
            viewTypes.Push(type);
        }
        return GenericSpecificName(type);
    }

    private string GenericSpecificName(Type type)
    {
        //todo: update for Typescript's generic syntax once invented
        string name = type.Name;
        int index = name.IndexOf('`');
        name = index == -1 ? name : name.Substring(0, index);
        if (type.IsGenericType)
        {
            name += "Of"+string.Join("And", type.GenericTypeArguments.Select(GenericSpecificName));
        }
        return name;
    }

    private string FirstCharLowered(string s)
    {
        return Regex.Replace(s, "^.", x => x.Value.ToLowerInvariant());
    }

    Dictionary<Assembly, XDocument> xmlDocs = new Dictionary<Assembly, XDocument>(); 

    private XDocument XmlDocForAssembly(Assembly a)
    {
        XDocument value;
        if (!xmlDocs.TryGetValue(a, out value))
        {
            var path = new Uri(a.CodeBase.Replace(".dll", ".xml")).LocalPath;
            xmlDocs[a] = value = File.Exists(path) ? XDocument.Load(path) : null;
        }
        return value;
    }

    private MethodDocs GetXmlDocForMethod(MethodInfo method)
    {
        var xmlDocForHub = XmlDocForAssembly(method.DeclaringType.Assembly);
        if (xmlDocForHub == null)
        {
            return new MethodDocs();
        }

        var methodName = string.Format("M:{0}.{1}({2})", method.DeclaringType.FullName, method.Name, string.Join(",", method.GetParameters().Select(x => x.ParameterType.FullName)));
        var xElement = xmlDocForHub.Descendants("member").SingleOrDefault(x => (string) x.Attribute("name") == methodName);
        return xElement==null?new MethodDocs():new MethodDocs(xElement);
    }

    private class MethodDocs
    {
        public MethodDocs()
        {
            Summary = "---";
            Parameters = new Dictionary<string, string>();
        }

        public MethodDocs(XElement xElement)
        {
            Summary = ((string) xElement.Element("summary") ?? "").Trim();
            Parameters = xElement.Elements("param").ToDictionary(x => (string) x.Attribute("name"), x=>x.Value);
        }

        public string Summary { get; set; }
        public Dictionary<string, string> Parameters { get; set; }
    
        public string ParameterSummary(string name)
        {
            if (Parameters.ContainsKey(name))
            {
                return Parameters[name];
            }
            return "";
        }
    }

#>
